# 树

树是一种非线性数据结构。树结构的基本单位是节点。节点之间的链接，称为分支（branch）。节点与分支形成树状，结构的开端，称为根（root），或根结点。根节点之外的节点，称为子节点（child）。没有链接到其他子节点的节点，称为叶节点（leaf）。

- 树的高度：节点到叶子节点的最大值就是其高度。
- 树的深度：高度和深度是相反的，高度是从下往上数，深度是从上往下。因此根节点的深度和叶子节点的高度是 0。
- 树的层：根开始定义，根为第一层，根的孩子为第二层。
- 二叉树，三叉树，。。。 N 叉树，由其子节点最多可以有几个决定，最多有 N 个就是 N 叉树。

## 二叉树

二叉树是树结构的一种，两个叉就是说每个节点最多只有两个子节点，我们习惯称之为左节点和右节点。

### 分类

- 完全二叉树
- 满二叉树
- 二叉搜索树
- ​平衡二叉树​
- 红黑树
- 。。。


## 诀窍

### 一个中心
一个中心指的是树的遍历。整个树的专题只有一个中心点，那就是树的遍历。

树的遍历又可以分为两个基本类型，分别是深度优先遍历和广度优先遍历

### 两个基本点
面提到了树的遍历有两种基本方式，分别是深度优先遍历（以下简称 DFS）和广度优先遍历（以下简称 BFS），这就是两个基本点。这两种遍历方式下面又会细分几种方式。比如 DFS 细分为前中后序遍历， BFS 细分为带层的和不带层的。
DFS 适合做一些暴力枚举的题目，DFS 如果借助函数调用栈，则可以轻松地使用递归来实现。

#### 深度优先遍历

深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止，属于盲目搜索。

DFS 我们借助的是栈来完成。

#### 广度优先遍历


FS 也是图论中算法的一种，不同于 DFS， BFS 采用横向搜索的方式，在数据结构上通常采用队列结构。 注意，DFS 我们借助的是栈来完成，而这里借助的是队列。

BFS 比较适合找最短距离/路径和某一个距离的目标。


### 三种题型

树的题目就三种类型，分别是：搜索类，构建类和修改类，而这三类题型的比例也是逐渐降低的，即搜索类的题目最多，其次是构建类，最后是修改类。

#### 搜索类

搜索类只有两种解法，那就是 DFS 和 BFS。


#### 构建类

除了搜索类，另外一个大头是构建类。构建类又分为两种：普通二叉树的构建和二叉搜索树的构建。

**普通二叉树的构建**

而普通二叉树的构建又分为三种：

1. 给你两种 DFS 的遍历的结果数组，让你构建出原始的树结构。比如根据先序遍历和后序遍历的数组，构造原始二叉树。

2. 给你一个 BFS 的遍历的结果数组，让你构建出原始的树结构。

3. 还有一种是给你描述一种场景，让你构造一个符合条件的二叉树。

**二叉搜索树的构建**

普通二叉树无法根据一种序列重构的原因是只知道根节点，无法区分左右子树。如果是二叉搜索树，那么就有可能根据一种遍历序列构造出来。 原因就在于二叉搜索树的根节点的值大于所有的左子树的值，且小于所有的右子树的值。因此我们可以根据这一特性去确定左右子树的位置。

#### 修改类

修改类的题目有两种基本类型。

**题目要求的修改**

一种是题目让你增加，删除节点，或者是修改节点的值或者指向。

**算法需要，自己修改**

### 四个重要概念

#### 二叉搜索树

二叉搜索树（Binary Search Tree），亦称二叉查找树。

二叉搜索树具有下列性质的二叉树：
- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
左、右子树也分别为二叉排序树；
- 没有键值相等的节点。

对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。

另外二叉查找树有一个性质，这个性质对于做题很多帮助，那就是： 二叉搜索树的中序遍历的结果是一个有序数组。

#### 完全二叉树

一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

#### 路径

#### 距离


### 七个技巧

#### dfs(root)

力扣的树题目的时候，函数的入参全都是叫 root。而这个技巧是说，我们在写 dfs 函数的时候，要将函数中表示当前节点的形参也写成 root

#### 单/双递归

树的题目大多数都可以用递归轻松地解决。如果一个递归不行，那么来两个。

如果题目有类似，任意节点开始 xxxx 或者所有 xxx这样的说法，就可以考虑使用双递归。但是如果递归中有重复计算，则可以使用双递归 + 记忆化 或者直接单递归。

#### 前后遍历

中序除了二叉搜索树，其他地方用的并不多。

如果是前序遍历，那么你可以想象上面的节点都处理好了，怎么处理的不用管。相应地如果是后序遍历，那么你可以想象下面的树都处理好了，怎么处理的不用管。

#### 虚拟节点

当你需要对树的头节点（在树中我们称之为根节点）进行修改的时候， 就可以考虑使用虚拟指针的技巧了。

另外一种是题目需要返回树中间的某个节点（不是返回根节点）。实际上也可借助虚拟节点。由于我上面提到的指针的操作，实际上，你可以新建一个虚拟头，然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。

#### 边界

**搜索类**

搜索类的题目，树的边界其实比较简单。 90% 以上的题目边界就两种情况。

1. 空节点

2. 叶子节点

**构建类**

1. 参数扩展的边界
2.  虚拟节点

#### 参数扩展大法

有时候，我们需要 dfs 携带更多的有用信息。典型的有以下三种情况：

1. 携带父亲或者爷爷的信息
```js
dfs(root, parent):
```

2. 携带路径信息，可以是路径和或者具体的路径数组等。
路径和：
```js
dfs(root, path_sum):
```
路径：
```js
dfs(root, path):
```


#### 返回元组/列表

dfs 函数的返回值是一个单值。而有时候为了方便计算，我们会返回一个数组或者元祖。

这个技巧和参数扩展有异曲同工之妙，只不过一个作用于函数参数，一个作用于函数返回值。
