# 二分法

二分查找又称折半搜索算法。狭义地来讲，二分查找是一种在有序数组查找某一特定元素的搜索算法。广义的二分查找是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3。


## 基本概念

### 解空间
解空间指的是**题目所有可能的解构成的集合**

对于搜索类题目，解空间一定是有限的，不然问题不可解。对于搜索类问题，第一步就是需要明确解空间，这样你才能够在解空间内进行搜索。这个技巧不仅适用于二分法，只要是搜索问题都可以使用，比如 DFS，BFS 以及回溯等。只不过对于二分法来说，明确解空间显得更为重要。

### 序列有序

虽然二分法不意味着需要序列有序，但大多数二分题目都有有序这个显著特征。只不过：
- 有的是题目直接限定了有序。这种题目通常难度不高，也容易让人想到用二分。
- 有的是需要你自己构造有序序列。这种类型的题目通常难度不低，需要大家有一定的观察能力。

### 极值

这里的极值通常指的是求第 k 大（或者第 k 小）的数。


## 一个中心

**折半**
折半的难点是根据什么条件舍弃哪一步部分。这里有两个关键字:
1. 什么条件
2. 舍弃哪部分

## 两种类型

1. 问题定义

常见变体：
- 如果存在多个满足条件的元素，返回最左边满足条件的索引。
- 如果存在多个满足条件的元素，返回最右边满足条件的索引。
- 数组不是整体有序的。 比如先升序再降序，或者先降序再升序。
- 将一维数组变成二维数组。
- 。。。

**前提：**
数组是有序的（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）


### 查找一个数

最简单的类型 - 查找某一个具体值 。

算法描述：
- 先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
- 如果目标元素大于中间元素，那么数组中小于中间元素的值都可以排除（由于数组有序，那么相当于是可以排除数组左侧的所有值），解空间可以收缩为 [mid+1, r]。
- 如果目标元素小于中间元素，那么数组中大于中间元素的值都可以排除（由于数组有序，那么相当于是可以排除数组右侧的所有值），解空间可以收缩为 [l, mid - 1]。
- 如果在某一步骤解空间为空，则代表找不到。


**复杂度分析**
由于这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。
- 平均时间复杂度： $O(logN)$
- 最坏时间复杂度： $O(logN)$
- 空间复杂度
  - 迭代: $O(1)$
  - 递归： $O(logN)$（无尾调用消除）


**解题思路**

首先定义解空间为 [left, right]，注意是左右都闭合，之后会用到这个点。

- 由于定义的解空间为 [left, right]，因此当 left <= right 的时候，解空间都不为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left <= right。

- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候解空间可缩小为 [mid + 1, right] （mid 以及 mid 左侧的数字被我们排除在外）
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候解空间可缩小为 [left, mid - 1] （mid 以及 mid 右侧的数字被我们排除在外）

- 循环结束都没有找到，则说明找不到，返回 -1 表示未找到。


模板
```js
function binarySearch(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while(left <= right) {
        let mid = left + (right - left) / 2;
        if(nums[mid] === target) {
            return mid;
        }
        if(nums[mid] < target) {
            left = mid + 1;
        }
        if(nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

### 寻找最左插入位置
上面我们讲了寻找满足条件的值。如果找不到，就返回 -1。那如果不是返回 -1，而是返回应该插入的位置，使得插入之后列表仍然有序呢？

**解题思路**
- 首先定义解空间为 [left, right]，注意是左右都闭合，之后会用到这个点。
- 由于我们定义的解空间为 [left, right]，因此当 left <= right 的时候，解空间都不为空。 也就是说我们的终止搜索条件为 left <= right。
- 当 A[mid] >= x，说明找到一个备胎，我们令 r = mid - 1 将 mid 从解空间排除，继续看看有没有更好的备胎。
- 当 A[mid] < x，说明 mid 根本就不是答案，直接更新 l = mid + 1，从而将 mid 从解空间排除。
- 最后解空间的 l 就是最好的备胎，备胎转正。


### 寻找最右插入位置

**解题思路**

- 首先定义解空间为 [left, right]，注意是左右都闭合，之后会用到这个点。
- 由于我们定义的解空间为 [left, right]，因此当 left <= right 的时候，解空间都不为空。 也就是说我们的终止搜索条件为 left <= right。
- 当 A[mid] > x，说明找到一个备胎，我们令 r = mid - 1 将 mid 从解空间排除，继续看看有没有更好的备胎。
- 当 A[mid] <= x，说明 mid 根本就不是答案，直接更新 l = mid + 1，从而将 mid 从解空间排除。
- 最后解空间的 l 就是最好的备胎，备胎转正。


而在实际的写代码过程中，我不会使用寻找满足条件的值模板，而是直接使用最左 或者 最右 插入模板。为什么呢？因为后者包含了前者，并还有前者实现不了的功能。比如我要实现寻找满足条件的值，就可直接使用最左插入模板找到插入索引 i，只不过最后判断一下 nums[i] 是否等于 target 即可，如果不等于则返回 -1，否则返回 i。这也是为什么我将二分分为两种类型，而不是三种甚至四种的原因。

对于最左和最右二分，简单用两句话总结一下：
1. 最左二分不断收缩右边界，最终返回左边界
2. 最右二分不断收缩左边界，最终返回右边界


## 四大应用

### 能力检测二分

能力检测二分一般是：定义函数 possible， 参数是 mid，返回值是布尔值。外层根据返回值调整"解空间"。

和最左最右二分这两种最最基本的类型相比，能力检测二分只是将 while 内部的 if 语句调整为了一个函数罢了。因此能力检测二分也分最左和最右两种基本类型。

题型：
875. 爱吃香蕉的珂珂（中等）

### 计数二分

### 前缀和二分
如果数组全是正的，那么其前缀和就是一个严格递增的数组，基于这个特性，我们可以在其之上做二分。类似的有单调栈/队列。

提出前缀和二分的核心的点在于让大家保持对有序序列的敏感度。

### 插入排序二分

除了上面的前缀和之外，我们还可以自行维护有序序列。一般有两种方式：
- 直接对序列排序。
- 遍历过程维护一个新的有序序列，有序序列的内容为已经遍历过的值的集合。
