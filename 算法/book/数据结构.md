# 数据结构

## 队列
受限，只能操作队尾跟队首。

遵循**先进先出**（FIFO）。

**实际使用**
HTTP1.1的对头阻塞问题。

其实队头阻塞是一个专有名词，不仅仅在 HTTP 有，交换器等其他地方也都涉及到了这个问题。实际上引起这个问题的根本原因是使用了队列这种数据结构。
协议规定， 对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个请求的响应收到了，才能发送下一个请求，这个时候就发生了阻塞，并且这个阻塞主要发生在客户端。

## 栈
受限，只能操作栈顶。
遵循**先进后出**（LIFO）

**实际应用**
浏览器的执行栈。

## 链表

react fiber基本原理的底层实现就是是使用链表。


## 非线性结构

使用非线性结构可以高效兼顾静态操作和动态操作。一般使用树去管理需要大量动态操作的数据。

### 树

一种递归的数据结构。

基本算法有前中后序遍历和层次遍历。

前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

树的性质：
- 如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。
- 任何一个节点到根节点存在唯一路径，路径的长度为节点所处的深度。



### 二叉树

二叉树是节点度数不超过二的树，是树的一种特殊子集。

二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者。


### 二叉查找树

二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。
二叉查找树具有下列性质的二叉树：

- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 左、右子树也分别为二叉排序树；
- 没有键值相等的节点。

对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。

### 二叉平衡树

一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。

基本操作：
- 旋转
- 插入
- 删除
- 查询前驱
- 查询后继


#### AVL
是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。