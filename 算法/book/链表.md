# 链表

数组是连续的内存空间，通常每一个单位的大小也是固定的，因此可以按下标随机访问。而链表则不一定连续，因此其查找只能依靠别的方式，一般我们是通过一个叫 next 指针来遍历查找。链表其实就是一个结构体。

## 基本操作

### 插入

插入只需要考虑要插入位置前驱节点和后继节点（双向链表的情况下需要更新后继节点）即可，其他节点不受影响，因此在给定指针的情况下插入的操作时间复杂度为O(1)。这里给定指针中的指针指的是插入位置的前驱节点。

如果没有给定指针，我们需要先遍历找到节点，因此最坏情况下时间复杂度为 O(N)。

### 删除

只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑边界条件。

### 遍历

```js
当前指针 =  头指针
2
while 当前节点不为空 {
3
   print(当前节点)
4
   当前指针 = 当前指针.next
5
}
```

## 解题思路

### 一个原则
画图

### 两个考点

1. 指针修改

典型就是链表反转

2. 链表拼接

### 三个注意

- 出现了环，造成死循环。
- 分不清边界，导致边界条件出错。
- 搞不懂递归怎么做


**环**
- 题目就有可能环，让你判断是否有环，以及环的位置。
- 题目链表没环，但是被你操作指针整出环了。

**边界**

- 如果题目的头节点可能被移除，那么考虑使用虚拟节点，这样头节点就变成了中间节点，就不需要为头节点做特殊判断了。
- 题目让你返回的不是原本的头节点，而是尾部节点或者其他中间节点，这个时候要注意指针的变化。

### 四个技巧

**虚拟头**

**快慢指针**
比如要找链表中间项就搞两个指针，一个大步走（一次走两步），一个小步走（一次走一步），这样快指针走到头，慢指针刚好在中间。 如果要求链表倒数第 2 个，那就让快指针先走一步，慢指针再走，这样快指针走到头，慢指针刚好在倒数第二个。

题型：
19. 删除链表的倒数第 N 个结点
141. 环形链表


**穿针引线**

**先穿再排后判空**