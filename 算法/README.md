# 算法总结

## 1. 递归算法

递归算法是一种直接或者间接调用自身函数或者方法的算法。

递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。

**优缺点：**
- 优点：实现简单易上手
- 缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出。

### 1.1 适用场景

递归算法一般用于解决三类问题：

- 数据的定义是按递归定义的。（斐波那契数列）
- 问题解法按递归算法实现。（回溯）
- 数据的结构形式是按递归定义的。（树的遍历，图的搜索）

**解体思路**
1. 明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出是什么，功能是什么，要完成什么样的一件事。
2. 寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回。
3. 明确递归关系式，怎么通过各种递归调用来组合解决当前问题。


### 1.2 经典问题
- 斐波那契数列
- 汉诺塔问题
- 树的遍历及相关操作



## 2. 分治算法

分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的。

分治，顾名思义，就是 分而治之 ，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。

### 2.1 适用场景

当出现满足以下条件的问题，可以尝试只用分治策略进行求解：

- 原始问题可以分成多个相似的子问题
- 子问题可以很简单的求解
- 原始问题的解是子问题解的合并
- 各个子问题是相互独立的，不包含相同的子问题

**解题思路**
1. 分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决，解决各个子问题
3. 合并，将各个子问题的解合并为原问题的解


### 2.2 经典问题
- 二分查找
- 归并排序
- 快速排序
- 汉诺塔问题
- React 时间分片


## 3. 贪心算法
期望通过局部的最优选择获得整体的最优选择。

### 3.1 适用场景
- 原问题复杂度过高
- 求全局最优解的数学模型难以建立或计算量过大
- 没有太大必要一定要求出全局最优解，“比较优”就可以


**解题思路**

1. 明确什么是最优解（期望）
2. 把问题分成多个步骤，每一步都需要满足：
    - 可行性：每一步都满足问题的约束
    - 局部最优：每一步都做出一个局部最优的选择
3. 不可取消：选择一旦做出，在后面遇到任何情况都不可取消
4. 叠加所有步骤的最优解，就是全局最优解


### 3.2 经典问题
- 最小生成树算法
- 单源最短路径的 Dijkstra 算法
- Huffman 压缩编码
- 背包问题
- 活动选择问题


## 4. 回溯算法
回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。

### 4.1 适用场景
通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。

### 4.2 经典问题
- 深度优先搜索
- 0-1背包问题
- 正则表达式匹配
- 八皇后
- 数独
- 全排列


## 5. 动态规范

动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

### 5.1 适用场景
动态规划适用于求解最优解问题。

**解题思路**
- 定义子问题
- 实现需要反复执行解决的子子问题部分
- 识别并求解出边界条件

### 5.2 经典问题
- 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
- 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值
- 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案
- 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径
- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）


## 6. 枚举算法

枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。

**解题思路**

- 确定枚举对象、枚举范围和判定条件。
- 逐一列举可能的解，验证每个解是否是问题的解。