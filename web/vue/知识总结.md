# vue知识

## `SPA`单页面的理解
`SPA`（ `single-page application` ）仅在 `Web` 页面初始化时加载相应的 `HTML`、`JavaScript` 和 `CSS`。一旦页面加载完成，`SPA` 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 `HTML` 内容的变换，`UI` 与用户的交互，避免页面的重新加载。

**优点**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；


**缺点**

- 初次加载耗时多：为实现单页 `Web` 应用功能及显示效果，需要在加载页面的时候将 `JavaScript`、`CSS` 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- `SEO` 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 `SEO` 上其有着天然的弱势。


## `v-if`与`v-show`的区别

`v-if` 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块(只有当条件为`true`时，该元素才会存在与`dom`树上)。

`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 `CSS` 的 `“display”` 属性进行切换(条件为`false`，`display`值为`none`，但此时`dom`树上存在这个元素).

所以，`v-if` 适用于在运行时很少改变条件，不需要频繁切换条件的场景；`v-show` 则适用于需要非常频繁切换条件的场景。


## `class`与`style`动态绑定的方式
1. 对象语法

`class`
```js
<div :class="{active: isActive, 'danger': hasError}"></div>

data: {
  isActive: true,
  hasError: false
}
```

`style`类似
```js
<div :style"{color: activeColor, fontSize: fontSize + 'px'}"></div>

data: {
  activeColor: 'blue',
  fontSize: 30
}
```

2. 数组语法

`class`
```js
<div :class="[isActive ? activeClass : '', errorClass]"></div>

data: {
  activeClass: 'active'
  errorClass: 'danger'
}
```

`style`类似
```js
<div :style"[styleColor, styleSize]"></div>

data: {
  styleColor: {
    color: 'red'
  },
  styleSize: {
    fontSize: '30px'
  }
}
```



## 组件通信的六种方式
### 一、 `props` / `$emit`

1. 父组件 -> 子组件

父组件
```html
  <Son :name = "name" />
```
子组件
```html
<template>
  <h1>{{name}}</h1>
</template>

<script>
export default {
  props: {
    name: {
      type: String,
      required: true
    }
  }
}
</script>
```

2. 子组件 -> 父组件

父组件
```html
<template>
  <div id="app">
    <Son :name="named" @updateName="updateName"></Son>
  </div>
</template>

<script>
import Son from './son.vue'

export default {
  name: 'App',
  data() {
    return {
      named: "leo"
    }
  },
  components: {
    Son
  },
  methods: {
    updateName(name) {
      this.named = name
    }
  }
}
</script>
```

子组件
```html
<template>
  <h1 @click="changeName">{{name}}</h1>
</template>

<script>
export default {
  props: {
    name: {
      type: String,
      required: true
    }
  },
  methods: {
    changeName() {
      this.$emit("updateName", "子组件向父组件传值")
    }
  }
}
</script>
```

### 二、 `$emit` / `$on`

这种方法通过一个空的`Vue`实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。

为了方便将`Bus`（空`vue`）定义在一个组件中，在实际的运用中一般会新建一个`Bus.js`
```js
import Vue from 'vue'
const Bus = new Vue()
export default Bus
```

组件1：
```js
import Bus from './Bus'

export default {
    data() {
        return {
            .........
            }
      },
  methods: {
        ....
        Bus.$emit('updateName', 'leo')
    },

  }
```

组件2：
```js
import Bus from './Bus'

export default {
    data() {
        return {
            .........
            }
      },
    mounted () {
       Bus.$on('updateName', content => { 
          console.log(content)
        });    
    }    
}
```


当然也可以直接将Bus注入到Vue根对象中。

```js
new Vue({
  render: h => h(App),
  data: {
    Bus: new Vue()
  }
}).$mount('#app')
```
在子组件中通过`this.$root.Bus.$on()`,`this.$root.Bus.$emit()`来调用。

将`bus`挂载到`vue.prototype`上。
```js
// plugin/index.js
import Bus from 'vue';
let install = function (Vue) {
    ... ...
    // 设置eventBus
    Vue.prototype.bus = new Bus();
    ... ...
}

export default {install};

// main.js
import Vue from 'vue';
import plugin from './plugin/index';

Vue.use(plugin);
```

组件一中定义

```js
created () {
  this.bus.$on('updateData', this.getdata);
}
```
组件二中调用
```js
this.bus.$emit('updateData', {loading: false});
```
注意：注册的总线事件要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况
```js
beforeDestroy () {
  this.bus.$off('updateData', this.getData);
}
```

### 三、 `vuex`

`Vuex` 是一个专为 `Vue.js`应用开发的状态管理模式，集中式存储管理应用所有组件的状态。
`Vuex`遵循“单向数据流”理念，易于问题追踪以及提高代码可维护性。

`state`保存数据状态，`mutations`用于修改状态。
```js
export default new Vuex.Store({
  state: { count:0 },
  mutations: {
    increment(state) {
      state.count += 1;
    }
  }
});
```
使用：
```html
<template>
<div>
  <div>数字： {{$store.state.count}}</div>
  <button @click="add">增加</button>
</div>
</template>

<script>
export default {
  methods: {
    add() {
      this.$store.commit("increment");
    } 
  }
};
</script>
```

#### `vuex`结合`localStorage`

`vuex` 是 `vue` 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在`vuex`里数据改变的时候把数据拷贝一份保存到`localStorage`里面，刷新之后，如果`localStorage`里有保存的数据，取出来再替换`store`里的`state`。

```js
let defaultNum = 0;
try {   // 用户关闭了本地存储功能，此时在外层加个try...catch
  if (!defaultNum){
    defaultNum = Number(window.localStorage.getItem('defaultNum'))
  }
}catch(e){}

export default new Vuex.Store({
  state: { count: defaultNum },
  mutations: {
    increment(state) {
      state.count += 1;
      try{
        window.localStorage.setItem('defaultNum', state.count);
      } catch (e) {}
    }
  }
});
```

这里需要注意的是：由于`vuex`里，我们保存的状态，是数字，而`localStorage`只支持字符串，所以需要转换一下。


### 四、`$attrs` / `$listeners`

多级组件嵌套需要传递数据时，通常使用的方法是通过`vuex`。但如果仅仅是传递数据，而不做中间处理，使用 `vuex` 处理，未免有点大材小用。为此`Vue2.4` 版本提供了另一种方法----`$attrs` / `$listeners`。

- `$attrs`：包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 `prop` 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `inheritAttrs` 选项一起使用。(`inheritAttrs`可以关闭自动挂载到组件根元素上的没有在`props`声明的属性，默认为`true`，也就是子组件上没有在`props`声明的属性都是添加到元素的标签上)

- `$listeners`：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件。


```html
// father.vue
<Son :foo="foo" :boo="boo" :coo="coo" :doo="doo" @method1="method1" @method2="method2"></Son>

<script>
import Son from './son.vue'

export default {
  name: 'App',
  data() {
    return {
      foo: "foo",
      boo: "boo",
      coo: "coo",
      doo: "doo"
    }
  },
  components: {
    Son
  },
  methods: {
    method1() {
      console.log('method1');
    },
    method2() {
      console.log('method2');
    }
  }
}
</script>


// son.vue
<div>
  <h1>{{foo}}</h1>
  <grand-son v-bind="$attrs" v-on="$listeners" />
</div>

<script>
import GrandSon from './grandSon.vue';
export default {
  components: {
    GrandSon
  },
  inheritAttrs: true,
  props: {
    foo: String
  },
  created() {
    console.log(this.$attrs);     // {boo: "boo", coo: "coo", doo: "doo"}
    console.log(this.$listeners); // {method1: ƒ, method2: ƒ}
  }
}
</script>

// grandSon.vue
<template>
  <div>
    <h2>boo: {{boo}}</h2>
  </div>
</template>

<script>
export default {
  props: {
    boo: String
  },
  created() {
    console.log(this.$attrs);      // {coo: "coo", doo: "doo"}
    console.log(this.$listeners);  // {method1: ƒ, method2: ƒ}
  }
}
</script>
```

`$attrs`表示没有继承数据的对象，格式为{属性名：属性值}。`Vue2.4`提供了`$attrs` ,`$listeners` 来传递数据与事件，跨级组件之间的通讯变得更简单。


### 五、`provide` / `inject`
`Vue2.2.0`以上允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过`provider`来提供变量，然后在子孙组件中通过`inject`来注入变量。

`provide` / `inject` API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

```html
// father.vue
<Son />

<script>
import Son from './son.vue'

export default {
  name: 'App',
  provide: {
    eoo: "eoo"
  }
}
</script>


// son.vue
<div>
  <h1>{{eoo}}</h1>
</div>

<script>
export default {
  inject: ['eoo'],
  created() {
    console.log(this.eoo);
  }
}
</script>

```
需要注意的是：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。也就是说当父组件的`eoo`值变动时，子组件的`eoo`值并不会改变。

#### `provide`与`inject` 实现数据响应式

一般来说，有两种办法：

- `provide`祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如`props`，`methods`。

- 使用Vue.observable 优化响应式 `provide`

```js
// 父组件
provide() {
  return {
    global: this
  }
},

// 子组件
inject: {
  global: {
    //函数式组件取值不一样
    default: () =>({})
  }
}
```
